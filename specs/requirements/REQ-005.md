# REQ-005: Section-Scoped Class Validation for DSL

**Version**: 1.0
**Created**: 2025-10-31
**Status**: Proposed

## Purpose

Enable sections to define which class instances (repeatable patterns) are allowed within them, providing hierarchical validation and preventing misplaced content in specification documents.

## Addresses

- [JOB-003](../jobs/JOB-003.md): Validate Specification Structure and Completeness

## Description

The DSL validation system shall support section-scoped class validation, where sections can declare which `SpecClass` instances are permitted within their scope. This provides stronger structural guarantees and more intuitive specification design.

### Current Limitation

Currently, class instances (e.g., Acceptance Criteria with pattern `AC-\d{2}:`) are validated globally across the entire document without regard to their containing section. This allows:
- AC instances appearing under any section (Purpose, Notes, etc.)
- No enforcement that the "Acceptance Criteria" section actually contains AC instances
- Unclear ownership of class instances in the specification schema

### Proposed Solution

Extend `SectionSpec` to include:
- `allowed_classes: list[str]` - Names of class types permitted in this section
- `require_classes: bool` - Whether at least one class instance must exist
- Validation logic that only searches for class instances within their allowed sections

### Design Principles

1. **Section Ownership**: Sections declare what can nest within them
2. **Clear Hierarchy**: Document structure is explicit and enforceable
3. **Backward Compatibility**: Sections without `allowed_classes` remain unrestricted
4. **Validation Scope**: Class validators only run on instances within allowed sections

### Example Usage

```python
class RequirementModule(SpecModule):
    sections: list[SectionSpec] = [
        SectionSpec(
            heading="Acceptance Criteria",
            heading_level=2,
            required=True,
            allowed_classes=["AcceptanceCriterion"],  # Only AC-XX allowed here
            require_classes=True,  # Must have at least one
        ),
        SectionSpec(
            heading="Test Cases",
            heading_level=2,
            required=False,
            allowed_classes=["TestCase"],  # Only TC-XX allowed here
        ),
    ]

    classes: dict[str, SpecClass] = {
        "AcceptanceCriterion": AcceptanceCriterion(),
        "TestCase": TestCase(),
    }
```

### Validation Behavior

```markdown
# REQ-001: Example

## Acceptance Criteria      ✓ Section exists

### AC-01: Valid Criterion  ✓ AC allowed in this section
**Given** a user
**When** they act
**Then** result occurs

## Notes                     ✓ Section exists

### AC-02: Invalid Here     ✗ ERROR: AC not allowed in Notes section
**Given** ...
```

## Acceptance Criteria

### AC-01: Add allowed_classes Field to SectionSpec

**Given** the `SectionSpec` model in `spec_check/dsl/models.py`
**When** defining a section specification
**Then** it shall have an `allowed_classes` field of type `list[str] | None`
**And** the field shall default to `None` (unrestricted)
**And** the field shall contain names of classes from the module's `classes` dictionary
**And** the field shall have a descriptive docstring

### AC-02: Add require_classes Field to SectionSpec

**Given** the `SectionSpec` model in `spec_check/dsl/models.py`
**When** a section has `allowed_classes` defined
**Then** it shall have a `require_classes` field of type `bool`
**And** the field shall default to `False`
**And** when `True`, validation shall error if no class instances are found
**And** when `False`, zero class instances shall be valid

### AC-03: Validate Only Within Section Scope

**Given** a document with sections that define `allowed_classes`
**When** the DSL validator performs Pass 5 (content validation)
**Then** it shall only search for class instances within their allowed sections
**And** it shall skip class validation for sections without `allowed_classes`
**And** it shall validate each class instance found with its content validator
**And** each error shall include context about the section and subsection

### AC-04: Detect Misplaced Class Instances

**Given** a document with a class instance outside its allowed section
**When** the DSL validator runs
**Then** it shall generate an error with type `misplaced_class_instance`
**And** the error shall identify the class instance heading
**And** the error shall identify the section where it was found
**And** the error shall suggest which section should contain it
**And** the error message shall be actionable

### AC-05: Enforce require_classes Constraint

**Given** a section with `allowed_classes` and `require_classes=True`
**When** the section exists but contains zero class instances
**Then** the validator shall generate an error with type `missing_required_classes`
**And** the error shall identify the section
**And** the error shall list the expected class types
**And** the error shall suggest adding at least one instance

### AC-06: Support Multiple Class Types Per Section

**Given** a section with `allowed_classes=["ClassA", "ClassB"]`
**When** the section contains instances of both ClassA and ClassB
**Then** both types shall be validated successfully
**And** instances of ClassA shall use ClassA's content validator
**And** instances of ClassB shall use ClassB's content validator

### AC-07: Backward Compatibility for Unrestricted Sections

**Given** a section without `allowed_classes` defined
**When** class instances appear within that section
**Then** they shall be validated using the global class search behavior
**And** no errors shall be raised about misplaced instances
**And** all existing validation behavior shall be preserved

### AC-08: Validate Correct Section Hierarchy

**Given** a class instance with heading level not matching section's subsection level
**When** found within an allowed section
**Then** it shall generate a warning about incorrect heading level
**And** the warning shall suggest the expected level based on section hierarchy

### AC-09: Update RequirementModule to Use Section-Scoped Classes

**Given** the `RequirementModule` definition in `spec_check/dsl/layers.py`
**When** defining the "Acceptance Criteria" section
**Then** it shall set `allowed_classes=["AcceptanceCriterion"]`
**And** it shall set `require_classes=True`
**And** no other sections shall allow `AcceptanceCriterion` instances

### AC-10: Comprehensive Test Coverage

**Given** the new section-scoped class validation feature
**When** implementing the feature
**Then** there shall be unit tests for `allowed_classes` field
**And** there shall be integration tests for section-scoped validation
**And** there shall be tests for `require_classes` enforcement
**And** there shall be tests for misplaced class detection
**And** there shall be tests for backward compatibility
**And** all tests shall pass

## Dependencies

- REQ-004: Four-Tier Document Classification for DSL Validation (provides base validation architecture)

## Implementation Notes

### Key Changes Required

1. **models.py**: Add `allowed_classes` and `require_classes` fields to `SectionSpec`
2. **validator.py**: Refactor `_validate_content()` to scope class search to sections
3. **layers.py**: Update `RequirementModule` to use section-scoped classes
4. **New error types**: `misplaced_class_instance`, `missing_required_classes`

### Validation Algorithm

```python
for section_def in module.sections:
    if section_def.allowed_classes:
        section_node = find_section(section_def.heading)

        # Find all class instances within this section
        found_instances = []
        for subsection in section_node.subsections:
            for class_name in section_def.allowed_classes:
                class_spec = module.classes[class_name]
                if matches_pattern(subsection, class_spec):
                    validate_class_instance(subsection, class_spec)
                    found_instances.append((class_name, subsection))

        # Check require_classes constraint
        if section_def.require_classes and not found_instances:
            error(f"Section '{section_def.heading}' requires at least one instance "
                  f"of: {', '.join(section_def.allowed_classes)}")
```

### Detection of Misplaced Instances

```python
# After validating allowed sections, check for violations
for section_node in all_sections:
    section_def = find_section_def(section_node)

    for subsection in section_node.subsections:
        for class_name, class_spec in module.classes.items():
            if matches_pattern(subsection, class_spec):
                # Found a class instance - is it allowed here?
                if section_def.allowed_classes is not None:
                    if class_name not in section_def.allowed_classes:
                        error(f"Class '{class_name}' instance found in section "
                              f"'{section_node.heading}' but not allowed there")
```

## Future Enhancements

- Support for nested class hierarchies (classes containing other classes)
- Cardinality constraints on classes per section (min/max instances)
- Cross-section class references (e.g., test cases referencing ACs)
- Dynamic class validation based on section content

## Jobs Addressed

- [JOB-003](../jobs/JOB-003.md): Validate Specification Structure and Completeness
